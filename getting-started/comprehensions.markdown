---
layout: getting-started
title: 列表解析
redirect_from: /getting_started/17.html
---

# {{ page.title }}

{% include toc.html %}

在 Elixir 中，经常遍历一个可枚举类型，过滤掉其中的一些结果，映射它的值到另一个列表。列表解析对于这一种结构是一种语法糖：用 `for` 这个特殊的形式把这些常见的任务组织起来。

举个例子，我们可以对一个列表把整数值映射到它的平方值列表：

```iex
iex> for n <- [1, 2, 3, 4], do: n * n
[1, 4, 9, 16]
```

一个列表解析包含三个部分：生成器，过滤器和集合。

## 生成器和过滤器

在上面的表达式中， `n <- [1, 2, 3, 4]` 是 **生成器**。它从字面上生成值用于列表解析。任意的可枚举类型都可以传入生成器表达式的右边：

```iex
iex> for n <- 1..4, do: n * n
[1, 4, 9, 16]
```

生成器表达式还支持在左侧进行模式匹配；所有不匹配的值会被 *忽略*。想像一下，如果不是用范围，我们有一个关键字列表，包含了原子 `:good` 或者 `:bad` 作为键，我们只想得到 `:good` 的平方值：

```iex
iex> values = [good: 1, good: 2, bad: 3, good: 4]
iex> for {:good, n} <- values, do: n * n
[1, 4, 16]
```

除了模式匹配，过滤器还能用于过滤掉一些特定的值。例如，我们可以过滤掉所有 3 的倍数，只对其余的值求平方：

```iex
iex> multiple_of_3? = fn(n) -> rem(n, 3) == 0 end
iex> for n <- 0..5, multiple_of_3?.(n), do: n * n
[0, 9]
```

列表解析过滤掉所有在过滤器表达式中返回 `false` 或 `nil` 的元素；其余的会被保留下来。

相比 `Enum` 和 `Stream` 模块中的函数，列表解析一般提供了简洁得多的表示。而且，列表解析还允许多个生成器和过滤器。这里有一个例子，遍历一个目录列表，并删除目录中所有文件：

```elixir
for dir  <- dirs,
    file <- File.ls!(dir),
    path = Path.join(dir, file),
    File.regular?(path) do
  File.rm!(path)
end
```

记住列表解析中的变量赋值，无论是在生成器中，还是在过滤器中或者是块中，都不影响列表解析外部的环境。

## 二进制串生成器

二进制串生成器也是支持的，当你需要解析二进制串流的时候会非常有用。以下的例子，从一个二进制中接受遍历一个像素列表，把每个用红绿蓝三元色表示的值转换成一个包含三个元素的元组：

```iex
iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>
iex> for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b}
[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
```

一个二进制串生成器可以与「一般的」可枚举类型生成器一起使用，也可以用过滤器。

## 返回除了列表之外的结果

在上面的例子中，所有的列表解析都是返回列表作为结果。然而，给列表解析传一个 `:into` 选项，列表解析的结果可以被插入到不同的数据结构中。

例如，一个二进制串生成器可以通过 `:into` 选项，可以轻松地删除字符串中的所有空格：

```iex
iex> for <<c <- " hello world ">>, c != ?\s, into: "", do: <<c>>
"helloworld"
```

集合， map 和其它字典类型也可以用 `:into` 选项。一般来说， `:into` 选项接受任意实现了 `Collectable` 协议的结构。

`:into` 的一个常见的用法是不用通过键转换一个 map 中的值：

```iex
iex> for {key, val} <- %{"a" => 1, "b" => 2}, into: %{}, do: {key, val * val}
%{"a" => 1, "b" => 4}
```

让我们看看另一个使用流的例子。因为 `IO` 模块提供了流式接口（它们既是 `Enumerable` 也是 `Collectable`），可以用列表解析实现一个 echo 终端，无论输入什么字符都显示成大写的版本：

```iex
iex> stream = IO.stream(:stdio, :line)
iex> for line <- stream, into: stream do
...>   String.upcase(line) <> "\n"
...> end
```

现在在这个终端里输入任意的字符串，你会看到以大写的值显示出来。不幸的是，这个例子中的列表解析会止住你的 IEx shell，你要按两次 `Ctrl+C` 才能退出。 :)
